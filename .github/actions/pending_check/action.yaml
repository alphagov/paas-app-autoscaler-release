name: 'Pending-Check'
description: 'Creates a github-actions check-run for a workflow'
inputs:
  pending_check:
    required: true
    description: Action to execute - [ create, verify ]
  check_filter:
    description: jq match filter for job names
    required: true
    default: ".*acceptance tests"
    # Note: All jobs to verify need their names to to end consistently
    # (ie. "XYZ acceptance tests") in order to utilise correct filtering of checks.
    # use '.*' to filter all jobs in the workflow.

runs:
  using: 'composite'
  steps:
  - name: Creating the check
    shell: bash
    env:
      ACT_RUN: 'if [ "${ACT}" ] && [ "${ACT_OVERRIDE:-"false"}" == "false" ]; then echo "NOTICE: step is running via ACT - skipping"; exit 0; fi;'
      PR_SHA: "${{github.event.pull_request.head.sha}}"
      GH_RUN_ID: "${{ github.run_id }}"
      GITHUB_TOKEN: "${{ github.token }}"
      GITHUB_REPOSITORY: "${{ github.repository }}"
      WORKFLOW_NAME: "${{ github.workflow }}"
      PENDING_CHECK: "${{ inputs.pending_check }}"
      CHECK_FILTER: "${{ inputs.check_filter }}"
    run: |
      # Checking run under ACT with override option
      eval "${ACT_RUN}"
      set -euo pipefail

      checkruns_url="https://api.github.com/repos/${{ env.GITHUB_REPOSITORY }}/check-runs"
      checkruns_commit_url="https://api.github.com/repos/${{ env.GITHUB_REPOSITORY }}/commits/${{ env.PR_SHA }}/check-runs"
      curlopts=(-f --retry 5 -H 'Accept: application/vnd.github+json' -H 'Authorization: token ${{ env.GITHUB_TOKEN }}')


      function main {
        if [ "${{ env.PENDING_CHECK }}" == "create" ]; then
          check_create
        elif [ "${{ env.PENDING_CHECK }}" == "verify" ]; then
          check_verify
        else
          echo "ERROR: invalid action ${{ env.PENDING_CHECK }} for pending check. Allowed: create or verify"
          exit 1
        fi
      }

      #---------------------------------------------------------------------------------------------------------------------------------------------------------------------
      function check_create {
      echo '::group::Creating new check'
      curl -v "${curlopts[@]}" -POST "${checkruns_url}" \
       -d '
          {
          "name":        "${{env.check_name}}",
          "head_sha":    "${{env.PR_SHA}}",
          "status":      "in_progress",
          "external_id": "${{env.GH_RUN_ID}}",
          "output": {
                      "title":   "${{ env.WORKFLOW_NAME }} running",
                      "summary": "pending check for commit ${{env.PR_SHA}}",
                      "text":    "Awaiting check result..."
                    }
          }
      ' \
      -o new_check.json

      id=$(jq -r '.id' new_check.json)

      if [ -z "${id}" ]; then
        echo "ERROR: Failed to create the required check job"
        echo "Result of curl:"
        cat new_check.json
        exit 1
      fi
      echo "::endgroup::"

      echo "Id is: ${id}"
      }

      #---------------------------------------------------------------------------------------------------------------------------------------------------------------------
      function check_verify {

      #------
      function send_conclusion() {

        echo "Verifying: ${checkruns_url}/${id}"

        curl -s "${curlopts[@]}" -X PATCH "${checkruns_url}/${id}" \
        -d @- << END;
             { "name": "${{ env.check_name }}", "conclusion": "$1" }
      END
      }
      #------

      echo "::group::Getting the latest checks results"
      echo "Getting the last result"
      curl -s "${curlopts[@]}" "${checkruns_commit_url}" | jq '[.check_runs[] | select(.name=="${{ env.check_name }}")]' > results.json
      jq '.|last' results.json > latest_result.json

      id=$( jq '.id' latest_result.json )
      number_of_checks=$(jq '. | length' results.json)

      echo "== Latest ${{env.check_name}} check result =="
      echo
      cat latest_result.json
      echo "::endgroup::"

      echo "::group::Check Info"
      echo "Latest check id:${id}"
      echo "Number of checks for commit ${{ env.PR_SHA }} ${number_of_checks}"
      echo "::endgroup::"

      if [ ${number_of_checks} -eq 0 ]; then
        echo "ERROR: no checks were found this commit!"
        exit 1
      fi

      echo "::group::Retrieving status of jobs (checks_filter: ${{ inputs.check_filter }})"
        curl "${curlopts[@]}" "${checkruns_commit_url}" \
         |  jq '.check_runs[] | select(.conclusion == "failure") | select(.name? | match("${{ inputs.check_filter }}")) | " - \(.name): \(.html_url)"' > bad_jobs.txt
      ls -la bad_jobs.txt
      echo "::endgroup::"

      if [ -s bad_jobs.txt ]; then
        echo "=========================="
        echo "List of failed checks:"
        cat bad_jobs.txt
        echo "=========================="

        echo "::group::Sending failure conclusion to the workflow check"
          send_conclusion "failure"
        echo "::endgroup::"
        exit 1
      else
        echo "::group::Sending success conclusion to the workflow check"
          send_conclusion "success"
        echo "::endgroup::"
      fi
      }
      #---------------------------------------------------------------------------------------------------------------------------------------------------------------------


      # ++ start ++
      main